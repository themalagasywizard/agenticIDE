{
  "version": 3,
  "sources": ["../../@tauri-apps/plugin-fs/dist-js/index.js"],
  "sourcesContent": ["export { BaseDirectory } from '@tauri-apps/api/path';\r\nimport { Resource, invoke, Channel } from '@tauri-apps/api/core';\r\n\r\n// Copyright 2019-2023 Tauri Programme within The Commons Conservancy\r\n// SPDX-License-Identifier: Apache-2.0\r\n// SPDX-License-Identifier: MIT\r\n/**\r\n * Access the file system.\r\n *\r\n * ## Security\r\n *\r\n * This module prevents path traversal, not allowing parent directory accessors to be used\r\n * (i.e. \"/usr/path/to/../file\" or \"../path/to/file\" paths are not allowed).\r\n * Paths accessed with this API must be either relative to one of the {@link BaseDirectory | base directories}\r\n * or created with the {@link https://v2.tauri.app/reference/javascript/api/namespacepath/ | path API}.\r\n *\r\n * The API has a scope configuration that forces you to restrict the paths that can be accessed using glob patterns.\r\n *\r\n * The scope configuration is an array of glob patterns describing file/directory paths that are allowed.\r\n * For instance, this scope configuration allows **all** enabled `fs` APIs to (only) access files in the\r\n * *databases* directory of the {@link https://v2.tauri.app/reference/javascript/api/namespacepath/#appdatadir | `$APPDATA` directory}:\r\n * ```json\r\n * {\r\n *   \"permissions\": [\r\n *     {\r\n *       \"identifier\": \"fs:scope\",\r\n *       \"allow\": [{ \"path\": \"$APPDATA/databases/*\" }]\r\n *     }\r\n *   ]\r\n * }\r\n * ```\r\n *\r\n * Scopes can also be applied to specific `fs` APIs by using the API's identifier instead of `fs:scope`:\r\n * ```json\r\n * {\r\n *   \"permissions\": [\r\n *     {\r\n *       \"identifier\": \"fs:allow-exists\",\r\n *       \"allow\": [{ \"path\": \"$APPDATA/databases/*\" }]\r\n *     }\r\n *   ]\r\n * }\r\n * ```\r\n *\r\n * Notice the use of the `$APPDATA` variable. The value is injected at runtime, resolving to the {@link https://v2.tauri.app/reference/javascript/api/namespacepath/#appdatadir | app data directory}.\r\n *\r\n * The available variables are:\r\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#appconfigdir | $APPCONFIG},\r\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#appdatadir | $APPDATA},\r\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#applocaldatadir | $APPLOCALDATA},\r\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#appcachedir | $APPCACHE},\r\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#applogdir | $APPLOG},\r\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#audiodir | $AUDIO},\r\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#cachedir | $CACHE},\r\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#configdir | $CONFIG},\r\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#datadir | $DATA},\r\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#localdatadir | $LOCALDATA},\r\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#desktopdir | $DESKTOP},\r\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#documentdir | $DOCUMENT},\r\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#downloaddir | $DOWNLOAD},\r\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#executabledir | $EXE},\r\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#fontdir | $FONT},\r\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#homedir | $HOME},\r\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#picturedir | $PICTURE},\r\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#publicdir | $PUBLIC},\r\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#runtimedir | $RUNTIME},\r\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#templatedir | $TEMPLATE},\r\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#videodir | $VIDEO},\r\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#resourcedir | $RESOURCE},\r\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#tempdir | $TEMP}.\r\n *\r\n * Trying to execute any API with a URL not configured on the scope results in a promise rejection due to denied access.\r\n *\r\n * @module\r\n */\r\nvar SeekMode;\r\n(function (SeekMode) {\r\n    SeekMode[SeekMode[\"Start\"] = 0] = \"Start\";\r\n    SeekMode[SeekMode[\"Current\"] = 1] = \"Current\";\r\n    SeekMode[SeekMode[\"End\"] = 2] = \"End\";\r\n})(SeekMode || (SeekMode = {}));\r\nfunction parseFileInfo(r) {\r\n    return {\r\n        isFile: r.isFile,\r\n        isDirectory: r.isDirectory,\r\n        isSymlink: r.isSymlink,\r\n        size: r.size,\r\n        mtime: r.mtime !== null ? new Date(r.mtime) : null,\r\n        atime: r.atime !== null ? new Date(r.atime) : null,\r\n        birthtime: r.birthtime !== null ? new Date(r.birthtime) : null,\r\n        readonly: r.readonly,\r\n        fileAttributes: r.fileAttributes,\r\n        dev: r.dev,\r\n        ino: r.ino,\r\n        mode: r.mode,\r\n        nlink: r.nlink,\r\n        uid: r.uid,\r\n        gid: r.gid,\r\n        rdev: r.rdev,\r\n        blksize: r.blksize,\r\n        blocks: r.blocks\r\n    };\r\n}\r\n// https://gist.github.com/zapthedingbat/38ebfbedd98396624e5b5f2ff462611d\r\n/** Converts a big-endian eight byte array to number  */\r\nfunction fromBytes(buffer) {\r\n    const bytes = new Uint8ClampedArray(buffer);\r\n    const size = bytes.byteLength;\r\n    let x = 0;\r\n    for (let i = 0; i < size; i++) {\r\n        // eslint-disable-next-line security/detect-object-injection\r\n        const byte = bytes[i];\r\n        x *= 0x100;\r\n        x += byte;\r\n    }\r\n    return x;\r\n}\r\n/**\r\n *  The Tauri abstraction for reading and writing files.\r\n *\r\n * @since 2.0.0\r\n */\r\nclass FileHandle extends Resource {\r\n    /**\r\n     * Reads up to `p.byteLength` bytes into `p`. It resolves to the number of\r\n     * bytes read (`0` < `n` <= `p.byteLength`) and rejects if any error\r\n     * encountered. Even if `read()` resolves to `n` < `p.byteLength`, it may\r\n     * use all of `p` as scratch space during the call. If some data is\r\n     * available but not `p.byteLength` bytes, `read()` conventionally resolves\r\n     * to what is available instead of waiting for more.\r\n     *\r\n     * When `read()` encounters end-of-file condition, it resolves to EOF\r\n     * (`null`).\r\n     *\r\n     * When `read()` encounters an error, it rejects with an error.\r\n     *\r\n     * Callers should always process the `n` > `0` bytes returned before\r\n     * considering the EOF (`null`). Doing so correctly handles I/O errors that\r\n     * happen after reading some bytes and also both of the allowed EOF\r\n     * behaviors.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * import { open, BaseDirectory } from \"@tauri-apps/plugin-fs\"\r\n     * // if \"$APPCONFIG/foo/bar.txt\" contains the text \"hello world\":\r\n     * const file = await open(\"foo/bar.txt\", { baseDir: BaseDirectory.AppConfig });\r\n     * const buf = new Uint8Array(100);\r\n     * const numberOfBytesRead = await file.read(buf); // 11 bytes\r\n     * const text = new TextDecoder().decode(buf);  // \"hello world\"\r\n     * await file.close();\r\n     * ```\r\n     *\r\n     * @since 2.0.0\r\n     */\r\n    async read(buffer) {\r\n        if (buffer.byteLength === 0) {\r\n            return 0;\r\n        }\r\n        const data = await invoke('plugin:fs|read', {\r\n            rid: this.rid,\r\n            len: buffer.byteLength\r\n        });\r\n        // Rust side will never return an empty array for this command and\r\n        // ensure there is at least 8 elements there.\r\n        //\r\n        // This is an optimization to include the number of read bytes (as bigendian bytes)\r\n        // at the end of returned array to avoid serialization overhead of separate values.\r\n        const nread = fromBytes(data.slice(-8));\r\n        const bytes = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\r\n        buffer.set(bytes.slice(0, bytes.length - 8));\r\n        return nread === 0 ? null : nread;\r\n    }\r\n    /**\r\n     * Seek sets the offset for the next `read()` or `write()` to offset,\r\n     * interpreted according to `whence`: `Start` means relative to the\r\n     * start of the file, `Current` means relative to the current offset,\r\n     * and `End` means relative to the end. Seek resolves to the new offset\r\n     * relative to the start of the file.\r\n     *\r\n     * Seeking to an offset before the start of the file is an error. Seeking to\r\n     * any positive offset is legal, but the behavior of subsequent I/O\r\n     * operations on the underlying object is implementation-dependent.\r\n     * It returns the number of cursor position.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * import { open, SeekMode, BaseDirectory } from '@tauri-apps/plugin-fs';\r\n     *\r\n     * // Given hello.txt pointing to file with \"Hello world\", which is 11 bytes long:\r\n     * const file = await open('hello.txt', { read: true, write: true, truncate: true, create: true, baseDir: BaseDirectory.AppLocalData });\r\n     * await file.write(new TextEncoder().encode(\"Hello world\"));\r\n     *\r\n     * // Seek 6 bytes from the start of the file\r\n     * console.log(await file.seek(6, SeekMode.Start)); // \"6\"\r\n     * // Seek 2 more bytes from the current position\r\n     * console.log(await file.seek(2, SeekMode.Current)); // \"8\"\r\n     * // Seek backwards 2 bytes from the end of the file\r\n     * console.log(await file.seek(-2, SeekMode.End)); // \"9\" (e.g. 11-2)\r\n     *\r\n     * await file.close();\r\n     * ```\r\n     *\r\n     * @since 2.0.0\r\n     */\r\n    async seek(offset, whence) {\r\n        return await invoke('plugin:fs|seek', {\r\n            rid: this.rid,\r\n            offset,\r\n            whence\r\n        });\r\n    }\r\n    /**\r\n     * Returns a {@linkcode FileInfo } for this file.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * import { open, BaseDirectory } from '@tauri-apps/plugin-fs';\r\n     * const file = await open(\"file.txt\", { read: true, baseDir: BaseDirectory.AppLocalData });\r\n     * const fileInfo = await file.stat();\r\n     * console.log(fileInfo.isFile); // true\r\n     * await file.close();\r\n     * ```\r\n     *\r\n     * @since 2.0.0\r\n     */\r\n    async stat() {\r\n        const res = await invoke('plugin:fs|fstat', {\r\n            rid: this.rid\r\n        });\r\n        return parseFileInfo(res);\r\n    }\r\n    /**\r\n     * Truncates or extends this file, to reach the specified `len`.\r\n     * If `len` is not specified then the entire file contents are truncated.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * import { open, BaseDirectory } from '@tauri-apps/plugin-fs';\r\n     *\r\n     * // truncate the entire file\r\n     * const file = await open(\"my_file.txt\", { read: true, write: true, create: true, baseDir: BaseDirectory.AppLocalData });\r\n     * await file.truncate();\r\n     *\r\n     * // truncate part of the file\r\n     * const file = await open(\"my_file.txt\", { read: true, write: true, create: true, baseDir: BaseDirectory.AppLocalData });\r\n     * await file.write(new TextEncoder().encode(\"Hello World\"));\r\n     * await file.truncate(7);\r\n     * const data = new Uint8Array(32);\r\n     * await file.read(data);\r\n     * console.log(new TextDecoder().decode(data)); // Hello W\r\n     * await file.close();\r\n     * ```\r\n     *\r\n     * @since 2.0.0\r\n     */\r\n    async truncate(len) {\r\n        await invoke('plugin:fs|ftruncate', {\r\n            rid: this.rid,\r\n            len\r\n        });\r\n    }\r\n    /**\r\n     * Writes `data.byteLength` bytes from `data` to the underlying data stream. It\r\n     * resolves to the number of bytes written from `data` (`0` <= `n` <=\r\n     * `data.byteLength`) or reject with the error encountered that caused the\r\n     * write to stop early. `write()` must reject with a non-null error if\r\n     * would resolve to `n` < `data.byteLength`. `write()` must not modify the\r\n     * slice data, even temporarily.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * import { open, write, BaseDirectory } from '@tauri-apps/plugin-fs';\r\n     * const encoder = new TextEncoder();\r\n     * const data = encoder.encode(\"Hello world\");\r\n     * const file = await open(\"bar.txt\", { write: true, baseDir: BaseDirectory.AppLocalData });\r\n     * const bytesWritten = await file.write(data); // 11\r\n     * await file.close();\r\n     * ```\r\n     *\r\n     * @since 2.0.0\r\n     */\r\n    async write(data) {\r\n        return await invoke('plugin:fs|write', {\r\n            rid: this.rid,\r\n            data\r\n        });\r\n    }\r\n}\r\n/**\r\n * Creates a file if none exists or truncates an existing file and resolves to\r\n *  an instance of {@linkcode FileHandle }.\r\n *\r\n * @example\r\n * ```typescript\r\n * import { create, BaseDirectory } from \"@tauri-apps/plugin-fs\"\r\n * const file = await create(\"foo/bar.txt\", { baseDir: BaseDirectory.AppConfig });\r\n * await file.write(new TextEncoder().encode(\"Hello world\"));\r\n * await file.close();\r\n * ```\r\n *\r\n * @since 2.0.0\r\n */\r\nasync function create(path, options) {\r\n    if (path instanceof URL && path.protocol !== 'file:') {\r\n        throw new TypeError('Must be a file URL.');\r\n    }\r\n    const rid = await invoke('plugin:fs|create', {\r\n        path: path instanceof URL ? path.toString() : path,\r\n        options\r\n    });\r\n    return new FileHandle(rid);\r\n}\r\n/**\r\n * Open a file and resolve to an instance of {@linkcode FileHandle}. The\r\n * file does not need to previously exist if using the `create` or `createNew`\r\n * open options. It is the callers responsibility to close the file when finished\r\n * with it.\r\n *\r\n * @example\r\n * ```typescript\r\n * import { open, BaseDirectory } from \"@tauri-apps/plugin-fs\"\r\n * const file = await open(\"foo/bar.txt\", { read: true, write: true, baseDir: BaseDirectory.AppLocalData });\r\n * // Do work with file\r\n * await file.close();\r\n * ```\r\n *\r\n * @since 2.0.0\r\n */\r\nasync function open(path, options) {\r\n    if (path instanceof URL && path.protocol !== 'file:') {\r\n        throw new TypeError('Must be a file URL.');\r\n    }\r\n    const rid = await invoke('plugin:fs|open', {\r\n        path: path instanceof URL ? path.toString() : path,\r\n        options\r\n    });\r\n    return new FileHandle(rid);\r\n}\r\n/**\r\n * Copies the contents and permissions of one file to another specified path, by default creating a new file if needed, else overwriting.\r\n * @example\r\n * ```typescript\r\n * import { copyFile, BaseDirectory } from '@tauri-apps/plugin-fs';\r\n * await copyFile('app.conf', 'app.conf.bk', { fromPathBaseDir: BaseDirectory.AppConfig, toPathBaseDir: BaseDirectory.AppConfig });\r\n * ```\r\n *\r\n * @since 2.0.0\r\n */\r\nasync function copyFile(fromPath, toPath, options) {\r\n    if ((fromPath instanceof URL && fromPath.protocol !== 'file:')\r\n        || (toPath instanceof URL && toPath.protocol !== 'file:')) {\r\n        throw new TypeError('Must be a file URL.');\r\n    }\r\n    await invoke('plugin:fs|copy_file', {\r\n        fromPath: fromPath instanceof URL ? fromPath.toString() : fromPath,\r\n        toPath: toPath instanceof URL ? toPath.toString() : toPath,\r\n        options\r\n    });\r\n}\r\n/**\r\n * Creates a new directory with the specified path.\r\n * @example\r\n * ```typescript\r\n * import { mkdir, BaseDirectory } from '@tauri-apps/plugin-fs';\r\n * await mkdir('users', { baseDir: BaseDirectory.AppLocalData });\r\n * ```\r\n *\r\n * @since 2.0.0\r\n */\r\nasync function mkdir(path, options) {\r\n    if (path instanceof URL && path.protocol !== 'file:') {\r\n        throw new TypeError('Must be a file URL.');\r\n    }\r\n    await invoke('plugin:fs|mkdir', {\r\n        path: path instanceof URL ? path.toString() : path,\r\n        options\r\n    });\r\n}\r\n/**\r\n * Reads the directory given by path and returns an array of `DirEntry`.\r\n * @example\r\n * ```typescript\r\n * import { readDir, BaseDirectory } from '@tauri-apps/plugin-fs';\r\n * import { join } from '@tauri-apps/api/path';\r\n * const dir = \"users\"\r\n * const entries = await readDir('users', { baseDir: BaseDirectory.AppLocalData });\r\n * processEntriesRecursively(dir, entries);\r\n * async function processEntriesRecursively(parent, entries) {\r\n *   for (const entry of entries) {\r\n *     console.log(`Entry: ${entry.name}`);\r\n *     if (entry.isDirectory) {\r\n *        const dir = await join(parent, entry.name);\r\n *       processEntriesRecursively(dir, await readDir(dir, { baseDir: BaseDirectory.AppLocalData }))\r\n *     }\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @since 2.0.0\r\n */\r\nasync function readDir(path, options) {\r\n    if (path instanceof URL && path.protocol !== 'file:') {\r\n        throw new TypeError('Must be a file URL.');\r\n    }\r\n    return await invoke('plugin:fs|read_dir', {\r\n        path: path instanceof URL ? path.toString() : path,\r\n        options\r\n    });\r\n}\r\n/**\r\n * Reads and resolves to the entire contents of a file as an array of bytes.\r\n * TextDecoder can be used to transform the bytes to string if required.\r\n * @example\r\n * ```typescript\r\n * import { readFile, BaseDirectory } from '@tauri-apps/plugin-fs';\r\n * const contents = await readFile('avatar.png', { baseDir: BaseDirectory.Resource });\r\n * ```\r\n *\r\n * @since 2.0.0\r\n */\r\nasync function readFile(path, options) {\r\n    if (path instanceof URL && path.protocol !== 'file:') {\r\n        throw new TypeError('Must be a file URL.');\r\n    }\r\n    const arr = await invoke('plugin:fs|read_file', {\r\n        path: path instanceof URL ? path.toString() : path,\r\n        options\r\n    });\r\n    return arr instanceof ArrayBuffer ? new Uint8Array(arr) : Uint8Array.from(arr);\r\n}\r\n/**\r\n * Reads and returns the entire contents of a file as UTF-8 string.\r\n * @example\r\n * ```typescript\r\n * import { readTextFile, BaseDirectory } from '@tauri-apps/plugin-fs';\r\n * const contents = await readTextFile('app.conf', { baseDir: BaseDirectory.AppConfig });\r\n * ```\r\n *\r\n * @since 2.0.0\r\n */\r\nasync function readTextFile(path, options) {\r\n    if (path instanceof URL && path.protocol !== 'file:') {\r\n        throw new TypeError('Must be a file URL.');\r\n    }\r\n    const arr = await invoke('plugin:fs|read_text_file', {\r\n        path: path instanceof URL ? path.toString() : path,\r\n        options\r\n    });\r\n    const bytes = arr instanceof ArrayBuffer ? arr : Uint8Array.from(arr);\r\n    return new TextDecoder().decode(bytes);\r\n}\r\n/**\r\n * Returns an async {@linkcode AsyncIterableIterator} over the lines of a file as UTF-8 string.\r\n * @example\r\n * ```typescript\r\n * import { readTextFileLines, BaseDirectory } from '@tauri-apps/plugin-fs';\r\n * const lines = await readTextFileLines('app.conf', { baseDir: BaseDirectory.AppConfig });\r\n * for await (const line of lines) {\r\n *   console.log(line);\r\n * }\r\n * ```\r\n * You could also call {@linkcode AsyncIterableIterator.next} to advance the\r\n * iterator so you can lazily read the next line whenever you want.\r\n *\r\n * @since 2.0.0\r\n */\r\nasync function readTextFileLines(path, options) {\r\n    if (path instanceof URL && path.protocol !== 'file:') {\r\n        throw new TypeError('Must be a file URL.');\r\n    }\r\n    const pathStr = path instanceof URL ? path.toString() : path;\r\n    return await Promise.resolve({\r\n        path: pathStr,\r\n        rid: null,\r\n        async next() {\r\n            if (this.rid === null) {\r\n                this.rid = await invoke('plugin:fs|read_text_file_lines', {\r\n                    path: pathStr,\r\n                    options\r\n                });\r\n            }\r\n            const arr = await invoke('plugin:fs|read_text_file_lines_next', { rid: this.rid });\r\n            const bytes = arr instanceof ArrayBuffer ? new Uint8Array(arr) : Uint8Array.from(arr);\r\n            // Rust side will never return an empty array for this command and\r\n            // ensure there is at least one elements there.\r\n            //\r\n            // This is an optimization to include whether we finished iteration or not (1 or 0)\r\n            // at the end of returned array to avoid serialization overhead of separate values.\r\n            const done = bytes[bytes.byteLength - 1] === 1;\r\n            if (done) {\r\n                // a full iteration is over, reset rid for next iteration\r\n                this.rid = null;\r\n                return { value: null, done };\r\n            }\r\n            const line = new TextDecoder().decode(bytes.slice(0, bytes.byteLength));\r\n            return {\r\n                value: line,\r\n                done\r\n            };\r\n        },\r\n        [Symbol.asyncIterator]() {\r\n            return this;\r\n        }\r\n    });\r\n}\r\n/**\r\n * Removes the named file or directory.\r\n * If the directory is not empty and the `recursive` option isn't set to true, the promise will be rejected.\r\n * @example\r\n * ```typescript\r\n * import { remove, BaseDirectory } from '@tauri-apps/plugin-fs';\r\n * await remove('users/file.txt', { baseDir: BaseDirectory.AppLocalData });\r\n * await remove('users', { baseDir: BaseDirectory.AppLocalData });\r\n * ```\r\n *\r\n * @since 2.0.0\r\n */\r\nasync function remove(path, options) {\r\n    if (path instanceof URL && path.protocol !== 'file:') {\r\n        throw new TypeError('Must be a file URL.');\r\n    }\r\n    await invoke('plugin:fs|remove', {\r\n        path: path instanceof URL ? path.toString() : path,\r\n        options\r\n    });\r\n}\r\n/**\r\n * Renames (moves) oldpath to newpath. Paths may be files or directories.\r\n * If newpath already exists and is not a directory, rename() replaces it.\r\n * OS-specific restrictions may apply when oldpath and newpath are in different directories.\r\n *\r\n * On Unix, this operation does not follow symlinks at either path.\r\n *\r\n * @example\r\n * ```typescript\r\n * import { rename, BaseDirectory } from '@tauri-apps/plugin-fs';\r\n * await rename('avatar.png', 'deleted.png', { oldPathBaseDir: BaseDirectory.App, newPathBaseDir: BaseDirectory.AppLocalData });\r\n * ```\r\n *\r\n * @since 2.0.0\r\n */\r\nasync function rename(oldPath, newPath, options) {\r\n    if ((oldPath instanceof URL && oldPath.protocol !== 'file:')\r\n        || (newPath instanceof URL && newPath.protocol !== 'file:')) {\r\n        throw new TypeError('Must be a file URL.');\r\n    }\r\n    await invoke('plugin:fs|rename', {\r\n        oldPath: oldPath instanceof URL ? oldPath.toString() : oldPath,\r\n        newPath: newPath instanceof URL ? newPath.toString() : newPath,\r\n        options\r\n    });\r\n}\r\n/**\r\n * Resolves to a {@linkcode FileInfo} for the specified `path`. Will always\r\n * follow symlinks but will reject if the symlink points to a path outside of the scope.\r\n *\r\n * @example\r\n * ```typescript\r\n * import { stat, BaseDirectory } from '@tauri-apps/plugin-fs';\r\n * const fileInfo = await stat(\"hello.txt\", { baseDir: BaseDirectory.AppLocalData });\r\n * console.log(fileInfo.isFile); // true\r\n * ```\r\n *\r\n * @since 2.0.0\r\n */\r\nasync function stat(path, options) {\r\n    const res = await invoke('plugin:fs|stat', {\r\n        path: path instanceof URL ? path.toString() : path,\r\n        options\r\n    });\r\n    return parseFileInfo(res);\r\n}\r\n/**\r\n * Resolves to a {@linkcode FileInfo} for the specified `path`. If `path` is a\r\n * symlink, information for the symlink will be returned instead of what it\r\n * points to.\r\n *\r\n * @example\r\n * ```typescript\r\n * import { lstat, BaseDirectory } from '@tauri-apps/plugin-fs';\r\n * const fileInfo = await lstat(\"hello.txt\", { baseDir: BaseDirectory.AppLocalData });\r\n * console.log(fileInfo.isFile); // true\r\n * ```\r\n *\r\n * @since 2.0.0\r\n */\r\nasync function lstat(path, options) {\r\n    const res = await invoke('plugin:fs|lstat', {\r\n        path: path instanceof URL ? path.toString() : path,\r\n        options\r\n    });\r\n    return parseFileInfo(res);\r\n}\r\n/**\r\n * Truncates or extends the specified file, to reach the specified `len`.\r\n * If `len` is `0` or not specified, then the entire file contents are truncated.\r\n *\r\n * @example\r\n * ```typescript\r\n * import { truncate, readTextFile, writeTextFile, BaseDirectory } from '@tauri-apps/plugin-fs';\r\n * // truncate the entire file\r\n * await truncate(\"my_file.txt\", 0, { baseDir: BaseDirectory.AppLocalData });\r\n *\r\n * // truncate part of the file\r\n * const filePath = \"file.txt\";\r\n * await writeTextFile(filePath, \"Hello World\", { baseDir: BaseDirectory.AppLocalData });\r\n * await truncate(filePath, 7, { baseDir: BaseDirectory.AppLocalData });\r\n * const data = await readTextFile(filePath, { baseDir: BaseDirectory.AppLocalData });\r\n * console.log(data);  // \"Hello W\"\r\n * ```\r\n *\r\n * @since 2.0.0\r\n */\r\nasync function truncate(path, len, options) {\r\n    if (path instanceof URL && path.protocol !== 'file:') {\r\n        throw new TypeError('Must be a file URL.');\r\n    }\r\n    await invoke('plugin:fs|truncate', {\r\n        path: path instanceof URL ? path.toString() : path,\r\n        len,\r\n        options\r\n    });\r\n}\r\n/**\r\n * Write `data` to the given `path`, by default creating a new file if needed, else overwriting.\r\n * @example\r\n * ```typescript\r\n * import { writeFile, BaseDirectory } from '@tauri-apps/plugin-fs';\r\n *\r\n * let encoder = new TextEncoder();\r\n * let data = encoder.encode(\"Hello World\");\r\n * await writeFile('file.txt', data, { baseDir: BaseDirectory.AppLocalData });\r\n * ```\r\n *\r\n * @since 2.0.0\r\n */\r\nasync function writeFile(path, data, options) {\r\n    if (path instanceof URL && path.protocol !== 'file:') {\r\n        throw new TypeError('Must be a file URL.');\r\n    }\r\n    if (data instanceof ReadableStream) {\r\n        const file = await open(path, {\r\n            read: false,\r\n            create: true,\r\n            write: true,\r\n            ...options\r\n        });\r\n        const reader = data.getReader();\r\n        try {\r\n            while (true) {\r\n                const { done, value } = await reader.read();\r\n                if (done)\r\n                    break;\r\n                await file.write(value);\r\n            }\r\n        }\r\n        finally {\r\n            reader.releaseLock();\r\n            await file.close();\r\n        }\r\n    }\r\n    else {\r\n        await invoke('plugin:fs|write_file', data, {\r\n            headers: {\r\n                path: encodeURIComponent(path instanceof URL ? path.toString() : path),\r\n                options: JSON.stringify(options)\r\n            }\r\n        });\r\n    }\r\n}\r\n/**\r\n  * Writes UTF-8 string `data` to the given `path`, by default creating a new file if needed, else overwriting.\r\n    @example\r\n  * ```typescript\r\n  * import { writeTextFile, BaseDirectory } from '@tauri-apps/plugin-fs';\r\n  *\r\n  * await writeTextFile('file.txt', \"Hello world\", { baseDir: BaseDirectory.AppLocalData });\r\n  * ```\r\n  *\r\n  * @since 2.0.0\r\n  */\r\nasync function writeTextFile(path, data, options) {\r\n    if (path instanceof URL && path.protocol !== 'file:') {\r\n        throw new TypeError('Must be a file URL.');\r\n    }\r\n    const encoder = new TextEncoder();\r\n    await invoke('plugin:fs|write_text_file', encoder.encode(data), {\r\n        headers: {\r\n            path: encodeURIComponent(path instanceof URL ? path.toString() : path),\r\n            options: JSON.stringify(options)\r\n        }\r\n    });\r\n}\r\n/**\r\n * Check if a path exists.\r\n * @example\r\n * ```typescript\r\n * import { exists, BaseDirectory } from '@tauri-apps/plugin-fs';\r\n * // Check if the `$APPDATA/avatar.png` file exists\r\n * await exists('avatar.png', { baseDir: BaseDirectory.AppData });\r\n * ```\r\n *\r\n * @since 2.0.0\r\n */\r\nasync function exists(path, options) {\r\n    if (path instanceof URL && path.protocol !== 'file:') {\r\n        throw new TypeError('Must be a file URL.');\r\n    }\r\n    return await invoke('plugin:fs|exists', {\r\n        path: path instanceof URL ? path.toString() : path,\r\n        options\r\n    });\r\n}\r\nclass Watcher extends Resource {\r\n}\r\nasync function watchInternal(paths, cb, options) {\r\n    const watchPaths = Array.isArray(paths) ? paths : [paths];\r\n    for (const path of watchPaths) {\r\n        if (path instanceof URL && path.protocol !== 'file:') {\r\n            throw new TypeError('Must be a file URL.');\r\n        }\r\n    }\r\n    const onEvent = new Channel();\r\n    onEvent.onmessage = cb;\r\n    const rid = await invoke('plugin:fs|watch', {\r\n        paths: watchPaths.map((p) => (p instanceof URL ? p.toString() : p)),\r\n        options,\r\n        onEvent\r\n    });\r\n    const watcher = new Watcher(rid);\r\n    return () => {\r\n        void watcher.close();\r\n    };\r\n}\r\n// TODO: Return `Watcher` instead in v3\r\n/**\r\n * Watch changes (after a delay) on files or directories.\r\n *\r\n * @since 2.0.0\r\n */\r\nasync function watch(paths, cb, options) {\r\n    return await watchInternal(paths, cb, {\r\n        delayMs: 2000,\r\n        ...options\r\n    });\r\n}\r\n// TODO: Return `Watcher` instead in v3\r\n/**\r\n * Watch changes on files or directories.\r\n *\r\n * @since 2.0.0\r\n */\r\nasync function watchImmediate(paths, cb, options) {\r\n    return await watchInternal(paths, cb, {\r\n        ...options,\r\n        delayMs: undefined\r\n    });\r\n}\r\n/**\r\n * Get the size of a file or directory. For files, the `stat` functions can be used as well.\r\n *\r\n * If `path` is a directory, this function will recursively iterate over every file and every directory inside of `path` and therefore will be very time consuming if used on larger directories.\r\n *\r\n * @example\r\n * ```typescript\r\n * import { size, BaseDirectory } from '@tauri-apps/plugin-fs';\r\n * // Get the size of the `$APPDATA/tauri` directory.\r\n * const dirSize = await size('tauri', { baseDir: BaseDirectory.AppData });\r\n * console.log(dirSize); // 1024\r\n * ```\r\n *\r\n * @since 2.1.0\r\n */\r\nasync function size(path) {\r\n    if (path instanceof URL && path.protocol !== 'file:') {\r\n        throw new TypeError('Must be a file URL.');\r\n    }\r\n    return await invoke('plugin:fs|size', {\r\n        path: path instanceof URL ? path.toString() : path\r\n    });\r\n}\r\n\r\nexport { FileHandle, SeekMode, copyFile, create, exists, lstat, mkdir, open, readDir, readFile, readTextFile, readTextFileLines, remove, rename, size, stat, truncate, watch, watchImmediate, writeFile, writeTextFile };\r\n"],
  "mappings": "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",
  "names": ["SeekMode", "size"]
}
