{
  "version": 3,
  "sources": ["../../@tauri-apps/plugin-fs/dist-js/index.js"],
  "sourcesContent": ["export { BaseDirectory } from '@tauri-apps/api/path';\nimport { Resource, invoke, Channel } from '@tauri-apps/api/core';\n\n// Copyright 2019-2023 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n/**\n * Access the file system.\n *\n * ## Security\n *\n * This module prevents path traversal, not allowing parent directory accessors to be used\n * (i.e. \"/usr/path/to/../file\" or \"../path/to/file\" paths are not allowed).\n * Paths accessed with this API must be either relative to one of the {@link BaseDirectory | base directories}\n * or created with the {@link https://v2.tauri.app/reference/javascript/api/namespacepath/ | path API}.\n *\n * The API has a scope configuration that forces you to restrict the paths that can be accessed using glob patterns.\n *\n * The scope configuration is an array of glob patterns describing file/directory paths that are allowed.\n * For instance, this scope configuration allows **all** enabled `fs` APIs to (only) access files in the\n * *databases* directory of the {@link https://v2.tauri.app/reference/javascript/api/namespacepath/#appdatadir | `$APPDATA` directory}:\n * ```json\n * {\n *   \"permissions\": [\n *     {\n *       \"identifier\": \"fs:scope\",\n *       \"allow\": [{ \"path\": \"$APPDATA/databases/*\" }]\n *     }\n *   ]\n * }\n * ```\n *\n * Scopes can also be applied to specific `fs` APIs by using the API's identifier instead of `fs:scope`:\n * ```json\n * {\n *   \"permissions\": [\n *     {\n *       \"identifier\": \"fs:allow-exists\",\n *       \"allow\": [{ \"path\": \"$APPDATA/databases/*\" }]\n *     }\n *   ]\n * }\n * ```\n *\n * Notice the use of the `$APPDATA` variable. The value is injected at runtime, resolving to the {@link https://v2.tauri.app/reference/javascript/api/namespacepath/#appdatadir | app data directory}.\n *\n * The available variables are:\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#appconfigdir | $APPCONFIG},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#appdatadir | $APPDATA},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#applocaldatadir | $APPLOCALDATA},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#appcachedir | $APPCACHE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#applogdir | $APPLOG},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#audiodir | $AUDIO},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#cachedir | $CACHE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#configdir | $CONFIG},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#datadir | $DATA},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#localdatadir | $LOCALDATA},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#desktopdir | $DESKTOP},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#documentdir | $DOCUMENT},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#downloaddir | $DOWNLOAD},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#executabledir | $EXE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#fontdir | $FONT},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#homedir | $HOME},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#picturedir | $PICTURE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#publicdir | $PUBLIC},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#runtimedir | $RUNTIME},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#templatedir | $TEMPLATE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#videodir | $VIDEO},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#resourcedir | $RESOURCE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#tempdir | $TEMP}.\n *\n * Trying to execute any API with a URL not configured on the scope results in a promise rejection due to denied access.\n *\n * @module\n */\nvar SeekMode;\n(function (SeekMode) {\n    SeekMode[SeekMode[\"Start\"] = 0] = \"Start\";\n    SeekMode[SeekMode[\"Current\"] = 1] = \"Current\";\n    SeekMode[SeekMode[\"End\"] = 2] = \"End\";\n})(SeekMode || (SeekMode = {}));\nfunction parseFileInfo(r) {\n    return {\n        isFile: r.isFile,\n        isDirectory: r.isDirectory,\n        isSymlink: r.isSymlink,\n        size: r.size,\n        mtime: r.mtime !== null ? new Date(r.mtime) : null,\n        atime: r.atime !== null ? new Date(r.atime) : null,\n        birthtime: r.birthtime !== null ? new Date(r.birthtime) : null,\n        readonly: r.readonly,\n        fileAttributes: r.fileAttributes,\n        dev: r.dev,\n        ino: r.ino,\n        mode: r.mode,\n        nlink: r.nlink,\n        uid: r.uid,\n        gid: r.gid,\n        rdev: r.rdev,\n        blksize: r.blksize,\n        blocks: r.blocks\n    };\n}\n// https://gist.github.com/zapthedingbat/38ebfbedd98396624e5b5f2ff462611d\n/** Converts a big-endian eight byte array to number  */\nfunction fromBytes(buffer) {\n    const bytes = new Uint8ClampedArray(buffer);\n    const size = bytes.byteLength;\n    let x = 0;\n    for (let i = 0; i < size; i++) {\n        // eslint-disable-next-line security/detect-object-injection\n        const byte = bytes[i];\n        x *= 0x100;\n        x += byte;\n    }\n    return x;\n}\n/**\n *  The Tauri abstraction for reading and writing files.\n *\n * @since 2.0.0\n */\nclass FileHandle extends Resource {\n    /**\n     * Reads up to `p.byteLength` bytes into `p`. It resolves to the number of\n     * bytes read (`0` < `n` <= `p.byteLength`) and rejects if any error\n     * encountered. Even if `read()` resolves to `n` < `p.byteLength`, it may\n     * use all of `p` as scratch space during the call. If some data is\n     * available but not `p.byteLength` bytes, `read()` conventionally resolves\n     * to what is available instead of waiting for more.\n     *\n     * When `read()` encounters end-of-file condition, it resolves to EOF\n     * (`null`).\n     *\n     * When `read()` encounters an error, it rejects with an error.\n     *\n     * Callers should always process the `n` > `0` bytes returned before\n     * considering the EOF (`null`). Doing so correctly handles I/O errors that\n     * happen after reading some bytes and also both of the allowed EOF\n     * behaviors.\n     *\n     * @example\n     * ```typescript\n     * import { open, BaseDirectory } from \"@tauri-apps/plugin-fs\"\n     * // if \"$APPCONFIG/foo/bar.txt\" contains the text \"hello world\":\n     * const file = await open(\"foo/bar.txt\", { baseDir: BaseDirectory.AppConfig });\n     * const buf = new Uint8Array(100);\n     * const numberOfBytesRead = await file.read(buf); // 11 bytes\n     * const text = new TextDecoder().decode(buf);  // \"hello world\"\n     * await file.close();\n     * ```\n     *\n     * @since 2.0.0\n     */\n    async read(buffer) {\n        if (buffer.byteLength === 0) {\n            return 0;\n        }\n        const data = await invoke('plugin:fs|read', {\n            rid: this.rid,\n            len: buffer.byteLength\n        });\n        // Rust side will never return an empty array for this command and\n        // ensure there is at least 8 elements there.\n        //\n        // This is an optimization to include the number of read bytes (as bigendian bytes)\n        // at the end of returned array to avoid serialization overhead of separate values.\n        const nread = fromBytes(data.slice(-8));\n        const bytes = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\n        buffer.set(bytes.slice(0, bytes.length - 8));\n        return nread === 0 ? null : nread;\n    }\n    /**\n     * Seek sets the offset for the next `read()` or `write()` to offset,\n     * interpreted according to `whence`: `Start` means relative to the\n     * start of the file, `Current` means relative to the current offset,\n     * and `End` means relative to the end. Seek resolves to the new offset\n     * relative to the start of the file.\n     *\n     * Seeking to an offset before the start of the file is an error. Seeking to\n     * any positive offset is legal, but the behavior of subsequent I/O\n     * operations on the underlying object is implementation-dependent.\n     * It returns the number of cursor position.\n     *\n     * @example\n     * ```typescript\n     * import { open, SeekMode, BaseDirectory } from '@tauri-apps/plugin-fs';\n     *\n     * // Given hello.txt pointing to file with \"Hello world\", which is 11 bytes long:\n     * const file = await open('hello.txt', { read: true, write: true, truncate: true, create: true, baseDir: BaseDirectory.AppLocalData });\n     * await file.write(new TextEncoder().encode(\"Hello world\"));\n     *\n     * // Seek 6 bytes from the start of the file\n     * console.log(await file.seek(6, SeekMode.Start)); // \"6\"\n     * // Seek 2 more bytes from the current position\n     * console.log(await file.seek(2, SeekMode.Current)); // \"8\"\n     * // Seek backwards 2 bytes from the end of the file\n     * console.log(await file.seek(-2, SeekMode.End)); // \"9\" (e.g. 11-2)\n     *\n     * await file.close();\n     * ```\n     *\n     * @since 2.0.0\n     */\n    async seek(offset, whence) {\n        return await invoke('plugin:fs|seek', {\n            rid: this.rid,\n            offset,\n            whence\n        });\n    }\n    /**\n     * Returns a {@linkcode FileInfo } for this file.\n     *\n     * @example\n     * ```typescript\n     * import { open, BaseDirectory } from '@tauri-apps/plugin-fs';\n     * const file = await open(\"file.txt\", { read: true, baseDir: BaseDirectory.AppLocalData });\n     * const fileInfo = await file.stat();\n     * console.log(fileInfo.isFile); // true\n     * await file.close();\n     * ```\n     *\n     * @since 2.0.0\n     */\n    async stat() {\n        const res = await invoke('plugin:fs|fstat', {\n            rid: this.rid\n        });\n        return parseFileInfo(res);\n    }\n    /**\n     * Truncates or extends this file, to reach the specified `len`.\n     * If `len` is not specified then the entire file contents are truncated.\n     *\n     * @example\n     * ```typescript\n     * import { open, BaseDirectory } from '@tauri-apps/plugin-fs';\n     *\n     * // truncate the entire file\n     * const file = await open(\"my_file.txt\", { read: true, write: true, create: true, baseDir: BaseDirectory.AppLocalData });\n     * await file.truncate();\n     *\n     * // truncate part of the file\n     * const file = await open(\"my_file.txt\", { read: true, write: true, create: true, baseDir: BaseDirectory.AppLocalData });\n     * await file.write(new TextEncoder().encode(\"Hello World\"));\n     * await file.truncate(7);\n     * const data = new Uint8Array(32);\n     * await file.read(data);\n     * console.log(new TextDecoder().decode(data)); // Hello W\n     * await file.close();\n     * ```\n     *\n     * @since 2.0.0\n     */\n    async truncate(len) {\n        await invoke('plugin:fs|ftruncate', {\n            rid: this.rid,\n            len\n        });\n    }\n    /**\n     * Writes `data.byteLength` bytes from `data` to the underlying data stream. It\n     * resolves to the number of bytes written from `data` (`0` <= `n` <=\n     * `data.byteLength`) or reject with the error encountered that caused the\n     * write to stop early. `write()` must reject with a non-null error if\n     * would resolve to `n` < `data.byteLength`. `write()` must not modify the\n     * slice data, even temporarily.\n     *\n     * @example\n     * ```typescript\n     * import { open, write, BaseDirectory } from '@tauri-apps/plugin-fs';\n     * const encoder = new TextEncoder();\n     * const data = encoder.encode(\"Hello world\");\n     * const file = await open(\"bar.txt\", { write: true, baseDir: BaseDirectory.AppLocalData });\n     * const bytesWritten = await file.write(data); // 11\n     * await file.close();\n     * ```\n     *\n     * @since 2.0.0\n     */\n    async write(data) {\n        return await invoke('plugin:fs|write', {\n            rid: this.rid,\n            data\n        });\n    }\n}\n/**\n * Creates a file if none exists or truncates an existing file and resolves to\n *  an instance of {@linkcode FileHandle }.\n *\n * @example\n * ```typescript\n * import { create, BaseDirectory } from \"@tauri-apps/plugin-fs\"\n * const file = await create(\"foo/bar.txt\", { baseDir: BaseDirectory.AppConfig });\n * await file.write(new TextEncoder().encode(\"Hello world\"));\n * await file.close();\n * ```\n *\n * @since 2.0.0\n */\nasync function create(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const rid = await invoke('plugin:fs|create', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    return new FileHandle(rid);\n}\n/**\n * Open a file and resolve to an instance of {@linkcode FileHandle}. The\n * file does not need to previously exist if using the `create` or `createNew`\n * open options. It is the callers responsibility to close the file when finished\n * with it.\n *\n * @example\n * ```typescript\n * import { open, BaseDirectory } from \"@tauri-apps/plugin-fs\"\n * const file = await open(\"foo/bar.txt\", { read: true, write: true, baseDir: BaseDirectory.AppLocalData });\n * // Do work with file\n * await file.close();\n * ```\n *\n * @since 2.0.0\n */\nasync function open(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const rid = await invoke('plugin:fs|open', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    return new FileHandle(rid);\n}\n/**\n * Copies the contents and permissions of one file to another specified path, by default creating a new file if needed, else overwriting.\n * @example\n * ```typescript\n * import { copyFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n * await copyFile('app.conf', 'app.conf.bk', { fromPathBaseDir: BaseDirectory.AppConfig, toPathBaseDir: BaseDirectory.AppConfig });\n * ```\n *\n * @since 2.0.0\n */\nasync function copyFile(fromPath, toPath, options) {\n    if ((fromPath instanceof URL && fromPath.protocol !== 'file:')\n        || (toPath instanceof URL && toPath.protocol !== 'file:')) {\n        throw new TypeError('Must be a file URL.');\n    }\n    await invoke('plugin:fs|copy_file', {\n        fromPath: fromPath instanceof URL ? fromPath.toString() : fromPath,\n        toPath: toPath instanceof URL ? toPath.toString() : toPath,\n        options\n    });\n}\n/**\n * Creates a new directory with the specified path.\n * @example\n * ```typescript\n * import { mkdir, BaseDirectory } from '@tauri-apps/plugin-fs';\n * await mkdir('users', { baseDir: BaseDirectory.AppLocalData });\n * ```\n *\n * @since 2.0.0\n */\nasync function mkdir(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    await invoke('plugin:fs|mkdir', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n}\n/**\n * Reads the directory given by path and returns an array of `DirEntry`.\n * @example\n * ```typescript\n * import { readDir, BaseDirectory } from '@tauri-apps/plugin-fs';\n * import { join } from '@tauri-apps/api/path';\n * const dir = \"users\"\n * const entries = await readDir('users', { baseDir: BaseDirectory.AppLocalData });\n * processEntriesRecursively(dir, entries);\n * async function processEntriesRecursively(parent, entries) {\n *   for (const entry of entries) {\n *     console.log(`Entry: ${entry.name}`);\n *     if (entry.isDirectory) {\n *        const dir = await join(parent, entry.name);\n *       processEntriesRecursively(dir, await readDir(dir, { baseDir: BaseDirectory.AppLocalData }))\n *     }\n *   }\n * }\n * ```\n *\n * @since 2.0.0\n */\nasync function readDir(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    return await invoke('plugin:fs|read_dir', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n}\n/**\n * Reads and resolves to the entire contents of a file as an array of bytes.\n * TextDecoder can be used to transform the bytes to string if required.\n * @example\n * ```typescript\n * import { readFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n * const contents = await readFile('avatar.png', { baseDir: BaseDirectory.Resource });\n * ```\n *\n * @since 2.0.0\n */\nasync function readFile(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const arr = await invoke('plugin:fs|read_file', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    return arr instanceof ArrayBuffer ? new Uint8Array(arr) : Uint8Array.from(arr);\n}\n/**\n * Reads and returns the entire contents of a file as UTF-8 string.\n * @example\n * ```typescript\n * import { readTextFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n * const contents = await readTextFile('app.conf', { baseDir: BaseDirectory.AppConfig });\n * ```\n *\n * @since 2.0.0\n */\nasync function readTextFile(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const arr = await invoke('plugin:fs|read_text_file', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    const bytes = arr instanceof ArrayBuffer ? arr : Uint8Array.from(arr);\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Returns an async {@linkcode AsyncIterableIterator} over the lines of a file as UTF-8 string.\n * @example\n * ```typescript\n * import { readTextFileLines, BaseDirectory } from '@tauri-apps/plugin-fs';\n * const lines = await readTextFileLines('app.conf', { baseDir: BaseDirectory.AppConfig });\n * for await (const line of lines) {\n *   console.log(line);\n * }\n * ```\n * You could also call {@linkcode AsyncIterableIterator.next} to advance the\n * iterator so you can lazily read the next line whenever you want.\n *\n * @since 2.0.0\n */\nasync function readTextFileLines(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const pathStr = path instanceof URL ? path.toString() : path;\n    return await Promise.resolve({\n        path: pathStr,\n        rid: null,\n        async next() {\n            if (this.rid === null) {\n                this.rid = await invoke('plugin:fs|read_text_file_lines', {\n                    path: pathStr,\n                    options\n                });\n            }\n            const arr = await invoke('plugin:fs|read_text_file_lines_next', { rid: this.rid });\n            const bytes = arr instanceof ArrayBuffer ? new Uint8Array(arr) : Uint8Array.from(arr);\n            // Rust side will never return an empty array for this command and\n            // ensure there is at least one elements there.\n            //\n            // This is an optimization to include whether we finished iteration or not (1 or 0)\n            // at the end of returned array to avoid serialization overhead of separate values.\n            const done = bytes[bytes.byteLength - 1] === 1;\n            if (done) {\n                // a full iteration is over, reset rid for next iteration\n                this.rid = null;\n                return { value: null, done };\n            }\n            const line = new TextDecoder().decode(bytes.slice(0, bytes.byteLength));\n            return {\n                value: line,\n                done\n            };\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        }\n    });\n}\n/**\n * Removes the named file or directory.\n * If the directory is not empty and the `recursive` option isn't set to true, the promise will be rejected.\n * @example\n * ```typescript\n * import { remove, BaseDirectory } from '@tauri-apps/plugin-fs';\n * await remove('users/file.txt', { baseDir: BaseDirectory.AppLocalData });\n * await remove('users', { baseDir: BaseDirectory.AppLocalData });\n * ```\n *\n * @since 2.0.0\n */\nasync function remove(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    await invoke('plugin:fs|remove', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n}\n/**\n * Renames (moves) oldpath to newpath. Paths may be files or directories.\n * If newpath already exists and is not a directory, rename() replaces it.\n * OS-specific restrictions may apply when oldpath and newpath are in different directories.\n *\n * On Unix, this operation does not follow symlinks at either path.\n *\n * @example\n * ```typescript\n * import { rename, BaseDirectory } from '@tauri-apps/plugin-fs';\n * await rename('avatar.png', 'deleted.png', { oldPathBaseDir: BaseDirectory.App, newPathBaseDir: BaseDirectory.AppLocalData });\n * ```\n *\n * @since 2.0.0\n */\nasync function rename(oldPath, newPath, options) {\n    if ((oldPath instanceof URL && oldPath.protocol !== 'file:')\n        || (newPath instanceof URL && newPath.protocol !== 'file:')) {\n        throw new TypeError('Must be a file URL.');\n    }\n    await invoke('plugin:fs|rename', {\n        oldPath: oldPath instanceof URL ? oldPath.toString() : oldPath,\n        newPath: newPath instanceof URL ? newPath.toString() : newPath,\n        options\n    });\n}\n/**\n * Resolves to a {@linkcode FileInfo} for the specified `path`. Will always\n * follow symlinks but will reject if the symlink points to a path outside of the scope.\n *\n * @example\n * ```typescript\n * import { stat, BaseDirectory } from '@tauri-apps/plugin-fs';\n * const fileInfo = await stat(\"hello.txt\", { baseDir: BaseDirectory.AppLocalData });\n * console.log(fileInfo.isFile); // true\n * ```\n *\n * @since 2.0.0\n */\nasync function stat(path, options) {\n    const res = await invoke('plugin:fs|stat', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    return parseFileInfo(res);\n}\n/**\n * Resolves to a {@linkcode FileInfo} for the specified `path`. If `path` is a\n * symlink, information for the symlink will be returned instead of what it\n * points to.\n *\n * @example\n * ```typescript\n * import { lstat, BaseDirectory } from '@tauri-apps/plugin-fs';\n * const fileInfo = await lstat(\"hello.txt\", { baseDir: BaseDirectory.AppLocalData });\n * console.log(fileInfo.isFile); // true\n * ```\n *\n * @since 2.0.0\n */\nasync function lstat(path, options) {\n    const res = await invoke('plugin:fs|lstat', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    return parseFileInfo(res);\n}\n/**\n * Truncates or extends the specified file, to reach the specified `len`.\n * If `len` is `0` or not specified, then the entire file contents are truncated.\n *\n * @example\n * ```typescript\n * import { truncate, readTextFile, writeTextFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n * // truncate the entire file\n * await truncate(\"my_file.txt\", 0, { baseDir: BaseDirectory.AppLocalData });\n *\n * // truncate part of the file\n * const filePath = \"file.txt\";\n * await writeTextFile(filePath, \"Hello World\", { baseDir: BaseDirectory.AppLocalData });\n * await truncate(filePath, 7, { baseDir: BaseDirectory.AppLocalData });\n * const data = await readTextFile(filePath, { baseDir: BaseDirectory.AppLocalData });\n * console.log(data);  // \"Hello W\"\n * ```\n *\n * @since 2.0.0\n */\nasync function truncate(path, len, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    await invoke('plugin:fs|truncate', {\n        path: path instanceof URL ? path.toString() : path,\n        len,\n        options\n    });\n}\n/**\n * Write `data` to the given `path`, by default creating a new file if needed, else overwriting.\n * @example\n * ```typescript\n * import { writeFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n *\n * let encoder = new TextEncoder();\n * let data = encoder.encode(\"Hello World\");\n * await writeFile('file.txt', data, { baseDir: BaseDirectory.AppLocalData });\n * ```\n *\n * @since 2.0.0\n */\nasync function writeFile(path, data, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    if (data instanceof ReadableStream) {\n        const file = await open(path, {\n            read: false,\n            create: true,\n            write: true,\n            ...options\n        });\n        const reader = data.getReader();\n        try {\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done)\n                    break;\n                await file.write(value);\n            }\n        }\n        finally {\n            reader.releaseLock();\n            await file.close();\n        }\n    }\n    else {\n        await invoke('plugin:fs|write_file', data, {\n            headers: {\n                path: encodeURIComponent(path instanceof URL ? path.toString() : path),\n                options: JSON.stringify(options)\n            }\n        });\n    }\n}\n/**\n  * Writes UTF-8 string `data` to the given `path`, by default creating a new file if needed, else overwriting.\n    @example\n  * ```typescript\n  * import { writeTextFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n  *\n  * await writeTextFile('file.txt', \"Hello world\", { baseDir: BaseDirectory.AppLocalData });\n  * ```\n  *\n  * @since 2.0.0\n  */\nasync function writeTextFile(path, data, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const encoder = new TextEncoder();\n    await invoke('plugin:fs|write_text_file', encoder.encode(data), {\n        headers: {\n            path: encodeURIComponent(path instanceof URL ? path.toString() : path),\n            options: JSON.stringify(options)\n        }\n    });\n}\n/**\n * Check if a path exists.\n * @example\n * ```typescript\n * import { exists, BaseDirectory } from '@tauri-apps/plugin-fs';\n * // Check if the `$APPDATA/avatar.png` file exists\n * await exists('avatar.png', { baseDir: BaseDirectory.AppData });\n * ```\n *\n * @since 2.0.0\n */\nasync function exists(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    return await invoke('plugin:fs|exists', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n}\nclass Watcher extends Resource {\n}\nasync function watchInternal(paths, cb, options) {\n    const watchPaths = Array.isArray(paths) ? paths : [paths];\n    for (const path of watchPaths) {\n        if (path instanceof URL && path.protocol !== 'file:') {\n            throw new TypeError('Must be a file URL.');\n        }\n    }\n    const onEvent = new Channel();\n    onEvent.onmessage = cb;\n    const rid = await invoke('plugin:fs|watch', {\n        paths: watchPaths.map((p) => (p instanceof URL ? p.toString() : p)),\n        options,\n        onEvent\n    });\n    const watcher = new Watcher(rid);\n    return () => {\n        void watcher.close();\n    };\n}\n// TODO: Return `Watcher` instead in v3\n/**\n * Watch changes (after a delay) on files or directories.\n *\n * @since 2.0.0\n */\nasync function watch(paths, cb, options) {\n    return await watchInternal(paths, cb, {\n        delayMs: 2000,\n        ...options\n    });\n}\n// TODO: Return `Watcher` instead in v3\n/**\n * Watch changes on files or directories.\n *\n * @since 2.0.0\n */\nasync function watchImmediate(paths, cb, options) {\n    return await watchInternal(paths, cb, {\n        ...options,\n        delayMs: undefined\n    });\n}\n/**\n * Get the size of a file or directory. For files, the `stat` functions can be used as well.\n *\n * If `path` is a directory, this function will recursively iterate over every file and every directory inside of `path` and therefore will be very time consuming if used on larger directories.\n *\n * @example\n * ```typescript\n * import { size, BaseDirectory } from '@tauri-apps/plugin-fs';\n * // Get the size of the `$APPDATA/tauri` directory.\n * const dirSize = await size('tauri', { baseDir: BaseDirectory.AppData });\n * console.log(dirSize); // 1024\n * ```\n *\n * @since 2.1.0\n */\nasync function size(path) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    return await invoke('plugin:fs|size', {\n        path: path instanceof URL ? path.toString() : path\n    });\n}\n\nexport { FileHandle, SeekMode, copyFile, create, exists, lstat, mkdir, open, readDir, readFile, readTextFile, readTextFileLines, remove, rename, size, stat, truncate, watch, watchImmediate, writeFile, writeTextFile };\n"],
  "mappings": "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",
  "names": ["SeekMode", "size"]
}
